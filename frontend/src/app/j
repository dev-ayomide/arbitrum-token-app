"use client";

import React, { useState, useEffect } from "react";
import * as ethers from "ethers";
import "../styles/globals.css";
import {
    getDefaultWallets,
    RainbowKitProvider,
    ConnectButton,
} from "@rainbow-me/rainbowkit";
import {
    configureChains,
    createConfig,
    WagmiConfig,
    useAccount,
    useContractWrite,
    useBalance,
    usePrepareContractWrite,
    useWaitForTransaction,
    useContractRead,
    useContractEvent,
} from "wagmi";
import { arbitrumSepolia } from "wagmi/chains";
import { publicProvider } from "wagmi/providers/public";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
    Card,
    CardContent,
    CardDescription,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
    AlertCircle,
    Coins,
    Send,
    ShieldCheck,
    RefreshCw,
    CreditCard,
    Clock,
    Info,
} from "lucide-react";
import "@rainbow-me/rainbowkit/styles.css";

// Contract Address and ABI
const contractAddress = process.env.NEXT_PUBLIC_CONTRACT_ADDRESS as `0x${string}`;
const contractABI = [
    {
        name: "mint",
        type: "function",
        stateMutability: "nonpayable",
        inputs: [],
        outputs: [],
    },
    {
        name: "transfer",
        type: "function",
        stateMutability: "nonpayable",
        inputs: [
            { name: "recipient", type: "address" },
            { name: "amount", type: "uint256" },
        ],
        outputs: [{ name: "", type: "bool" }],
    },
    {
        name: "balanceOf",
        type: "function",
        stateMutability: "view",
        inputs: [{ name: "account", type: "address" }],
        outputs: [{ name: "", type: "uint256" }],
    },
    {
        name: "approve",
        type: "function",
        stateMutability: "nonpayable",
        inputs: [
            { name: "spender", type: "address" },
            { name: "amount", type: "uint256" },
        ],
        outputs: [{ name: "", type: "bool" }],
    },
    {
        name: "allowance",
        type: "function",
        stateMutability: "view",
        inputs: [
            { name: "owner", type: "address" },
            { name: "spender", type: "address" },
        ],
        outputs: [{ name: "", type: "uint256" }],
    },
    {
        name: "Transfer",
        type: "event",
        inputs: [
            { name: "from", type: "address", indexed: true },
            { name: "to", type: "address", indexed: true },
            { name: "value", type: "uint256" },
        ],
    },
    {
        name: "Mint",
        type: "event",
        inputs: [
            { name: "to", type: "address", indexed: true },
            { name: "amount", type: "uint256" },
        ],
    },
] as const;

// Configure chains and providers
const { chains, publicClient } = configureChains(
    [arbitrumSepolia],
    [publicProvider()]
);

const { connectors } = getDefaultWallets({
    appName: "Arbitrum Token App",
    projectId: process.env.NEXT_PUBLIC_PROJECT_ID || "",
    chains,
});

const wagmiConfig = createConfig({
    autoConnect: true,
    connectors,
    publicClient,
});

const queryClient = new QueryClient();

export default function ComprehensiveTokenApp() {
    const [isMounted, setIsMounted] = useState(false);

    useEffect(() => {
        setIsMounted(true);
    }, []);

    if (!isMounted) return null;

    return (
        <WagmiConfig config={wagmiConfig}>
            <QueryClientProvider client={queryClient}>
                <RainbowKitProvider chains={chains}>
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-blue-100 flex items-center justify-center p-4">
                        <Card className="w-full max-w-2xl shadow-2xl border-none">
                            <CardHeader className="bg-blue-500 text-white rounded-t-lg p-6">
                                <div className="flex items-center justify-between">
                                    <div>
                                        <CardTitle className="text-3xl font-bold flex items-center gap-3">
                                            <Coins className="w-10 h-10" />
                                            Token Management Hub
                                        </CardTitle>
                                        <CardDescription className="text-blue-100 mt-2">
                                            Comprehensive Blockchain Token Interactions
                                        </CardDescription>
                                    </div>
                                    <div className="flex items-center">
                                        <ConnectButton accountStatus="avatar" showBalance={false} />
                                    </div>
                                </div>
                            </CardHeader>
                            <CardContent className="p-6">
                                <FullTokenInteractions />
                            </CardContent>
                        </Card>
                    </div>
                </RainbowKitProvider>
            </QueryClientProvider>
        </WagmiConfig>
    );
}

function FullTokenInteractions() {
    const { address, isConnected } = useAccount();
    const [activeTab, setActiveTab] = useState("overview");

    // Token Interaction States
    const [recipient, setRecipient] = useState("");
    const [amount, setAmount] = useState("");
    const [spenderAddress, setSpenderAddress] = useState("");
    const [approveAmount, setApproveAmount] = useState("");

    // Transaction & Status Management
    const [txMessage, setTxMessage] = useState("");
    const [txStatus, setTxStatus] = useState<"success" | "error" | null>(null);
    const [allowanceAmount, setAllowanceAmount] = useState<string | null>(null);

    const [transactions, setTransactions] = useState<Array<{
        type: 'Transfer' | 'Mint',
        from?: string,
        to: string,
        amount: string,
        timestamp: number
    }>>([]);

    // Balance and Contract Hooks
    const { data: balance, refetch: refetchBalance } = useBalance({
        address,
        token: contractAddress,
    });

    // Helper function for parsing and formatting ethers
    const parseTokenAmount = (amount: string) => {
        try {
            return ethers.parseUnits(amount, 18); // Assuming 18 decimal places
        } catch (error) {
            console.error("Amount parsing error:", error);
            return BigInt(0);
        }
    };

    // Contract Write Hooks
    const { config: mintConfig } = usePrepareContractWrite({
        address: contractAddress,
        abi: contractABI,
        functionName: "mint",
    });

    const {
        write: mint,
        data: mintData,
        isLoading: isMinting,
    } = useContractWrite(mintConfig);

    const { isLoading: isMintLoading } = useWaitForTransaction({
        hash: mintData?.hash,
        onSuccess: () => {
            setTxMessage("Tokens successfully minted!");
            setTxStatus("success");
            refetchBalance();
        },
    });

    const { config: transferConfig } = usePrepareContractWrite({
        address: contractAddress,
        abi: contractABI,
        functionName: "transfer",
        args: recipient && amount 
            ? [
                recipient as `0x${string}`, 
                parseTokenAmount(amount)
            ] 
            : undefined,
    });

    const {
        write: transfer,
        data: transferData,
        isLoading: isTransferring,
    } = useContractWrite(transferConfig);

    const { isLoading: isTransferLoading } = useWaitForTransaction({
        hash: transferData?.hash,
        onSuccess: () => {
            setTxMessage("Tokens successfully transferred!");
            setTxStatus("success");
            refetchBalance();
        },
    });

    const { config: approveConfig } = usePrepareContractWrite({
        address: contractAddress,
        abi: contractABI,
        functionName: "approve",
        args: spenderAddress && approveAmount
            ? [
                spenderAddress as `0x${string}`, 
                parseTokenAmount(approveAmount)
            ]
            : undefined,
    });

    const {
        write: approve,
        data: approveData,
        isLoading: isApproving,
    } = useContractWrite(approveConfig);

    const { isLoading: isApproveLoading } = useWaitForTransaction({
        hash: approveData?.hash,
        onSuccess: () => {
            setTxMessage("Tokens successfully approved!");
            setTxStatus("success");
            refetchBalance();
        },
    });

    const { data: allowanceData, refetch: refetchAllowance } = useContractRead({
        address: contractAddress,
        abi: contractABI,
        functionName: "allowance",
        args: address && spenderAddress
            ? [address, spenderAddress as `0x${string}`]
            : undefined,
    });

    useEffect(() => {
        if (allowanceData) {
            // Format allowance with 18 decimal places
            setAllowanceAmount(ethers.formatUnits(allowanceData.toString(), 18));
        }
    }, [allowanceData]);

    // Rest of the component remains the same...
    // (Include the rest of the FullTokenInteractions component from the previous implementation)
    // ... 

    return (
        // Existing return statement from the previous implementation
    );
}